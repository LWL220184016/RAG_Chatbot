import datetime

from qdrant_client import QdrantClient
from qdrant_client.http.models import Distance
from embedding_model.embedder import Embedder
from qdrant_client.http.models import Filter, FieldCondition, MatchValue, MatchText
# Initialize the Qdrant client (assuming a local instance running on default port)
client = QdrantClient(host="localhost", port=6333)
embedder = Embedder()
# Define a collection name and vector dimension
collection_name = "my_collection"
vector_size = 768  # For demonstration, we use a low-dimensional vector

# # (Re)create the collection with desired configuration
# # The collection will use cosine similarity (you can also choose "Euclid" or "Dot" for other metrics)
# client.recreate_collection(
#     collection_name=collection_name,
#     vectors_config={
#         "size": vector_size,
#         "distance": Distance.COSINE
#     }
# )
# # client.delete_collection(collection_name)

# # Define some simple data points with vectors and payloads
# points = []
# dataID = 0
# msg = [
#     "what is the answer of 739+191", 
#     "My favorite color is green",
#     "Data inserted successfully.",
#     "Enter a query: ",
#     "Define some simple data points with vectors and payloads",
#     "This will print the shape of the embeddings array",
#     "This is an example sentence",
#     "To show the size of the vectors generated by the embed method",
#     "This is a test message",
#     "I want to test the vector database.",
#     "Please give me sentences of different fields and meanings.",
#     "I want to see how the vector database works.",
#     "量子计算机利用量子比特实现并行计算，突破传统二进制限制",
#     "卷积神经网络在图像识别领域的准确率已超过人类水平",
#     "室温超导材料的突破将引发能源传输革命",
#     "星链计划通过低轨道卫星群构建全球互联网覆盖",
#     "CRISPR基因编辑技术可能治愈遗传性疾病",
#     "区块链的不可篡改性正在重塑金融审计体系",
#     "脑机接口设备可解码运动皮层的神经信号",
#     "碳纳米管晶体管使芯片制程突破1纳米成为可能",
#     "元宇宙中的数字孪生工厂能实时优化生产流程",
#     "AlphaFold3成功预测了98.7%的人类蛋白质结构",
# ]
# for m in msg:
#     dataID += 1
#     embeddings = embedder.embed([m])
#     print("====================================")
#     print(f"dataID: {dataID}")
#     print(f"Msg: {m}")
#     print(f"Vector size: {embeddings.shape}")
#     # print(f"Vector: {embeddings}")
#     time = datetime.datetime.now().isoformat() # example: 2025-03-03T06:42:15.786096
#     meta_data = {
#         "language": "en" if m.isascii() else "zh", 

#         # "source": "None",
#         "timestamp": time, 
#         # "metadata": {
#         #     "length": len(m),
#         #     "language": "en" if m.isascii() else "zh"
#         # }
#     }
#     points.append(
#         {
#             "id": dataID,
#             "vector": embeddings[0].tolist(),
#             "payload": {
#                 "msg": m,
#                 **meta_data  # Merge additional JSON data into the payload
#             }
#         }
#     )

# # Insert (upsert) the points into the collection
# client.upsert(collection_name=collection_name, points=points)
# print("Data inserted successfully.")

while True:
    query = input("Enter a query: ")
    query_vector = embedder.embed([query])

    print("Filter(language, timestamp) empty if you don't want to filter")
    user_filter = input("example(language=en,timestamp=2025-03): ")
    filter_conditions = []
    if "language=" in user_filter:
        language = user_filter.split("language=")[1].split(",")[0]
        filter_conditions.append(
            FieldCondition(
                key="language",
                match=MatchValue(value=language)
            )
        )
    if "timestamp=" in user_filter:
        timestamp_prefix = user_filter.split("timestamp=")[1].split(",")[0]
        # Check if the timestamp filter is for 2025-03 but not 2025-03-04
        filter_conditions.append(
            FieldCondition(
                key="timestamp",
                match=MatchText(text=timestamp_prefix)  # Match prefix 2025-03
            )
        )

    filter_condition = Filter(must=filter_conditions) if filter_conditions else None

    query_vector = embedder.embed([query])

    # Perform a search for the top 2 nearest neighbors
    search_result = client.query_points(
        collection_name=collection_name,
        query=query_vector[0],
        limit=2,
        query_filter=filter_condition
    )

    # Filter results based on timestamp prefix
    # filtered_results = [hit for hit in search_result[1] if hit.payload['timestamp'].startswith("2025-03") and not hit.payload['timestamp'].startswith("2025-03-04")]

    memory = []
    for point in search_result:
            if isinstance(point, tuple):
                # If the result is a tuple, access elements by index
                point = point[1]
                for p in point:
                    memory.append({
                        "message": p.payload['msg'],
                        "timestamp": p.payload['timestamp'],
                        "similarity_score": p.score,
                    })

    # Print out the search results
    print("Search results:")
    print(memory)
